<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Bristol JS</title>
        <link href="https://fonts.googleapis.com/css?family=Lora:400italic,700,400|Lato:300" rel="stylesheet">
		<style>
			body, html {
    font-family: Lora;
}

h1, h2, h3, h4, h5, h6 {
    font-family: Lato;
    font-weight: 300;
}

h1 {
    text-align: center;
    margin-top: 4em;
}

h2 + h1 {
    margin-top: 3em;
}

h1 + p {
    text-align: center;
}

h3, h4, h5, h6 {
    margin-top: 2em;
    text-decoration: underline;
}

.remark-slide-content {
    background: #083742;
    color: #fdf6e4;
}

.remark-slide-content h1 { font-size: 3em; }
.remark-slide-content h2 { font-size: 2em; }
.remark-slide-content h3 { font-size: 1.6em; }
.footnote {
    position: absolute;
    bottom: 3em;
}
li p { line-height: 1.25em; }
.red { color: #dd332e; }
.large { font-size: 2em; }
a, a > code {
    color: #d43682;
    text-decoration: none;
}
code {
    background: none repeat scroll 0 0 #657c83;
    border: 1px solid #94a2a2;
    border-radius: 3px 	;
    padding: 0 0.2em;
}
.remark-code, .remark-inline-code { font-family: "Inconsolata", "Courier", monospace; }
.remark-code-line-highlighted     { background-color: #373832; }
.pull-left {
    float: left;
    width: 47%;
}
.pull-right {
    float: right;
    width: 47%;
}
.pull-right ~ p {
    clear: both;
}
#slideshow .slide .content code {
    font-size: 0.8em;
}
#slideshow .slide .content pre code {
    font-size: 0.9em;
    padding: 15px;
}
.main-title, .title {
    background: #272822;
    color: #777872;
    text-shadow: 0 0 20px #333;
}
.title h1, .title h2, .main-title h1, .main-title h2 {
    color: #f3f3f3;
    line-height: 0.8em;
}
blockquote {
    color: #eee9d6;
    padding: 2em 4em 1em;
    text-align: center;
}
blockquote + p {
    margin: 0 2em;
    padding: 0 4em;
    color: #f3f3f3;
    text-align: right;
}
/* Custom */
.remark-code {
    display: block;
    padding: 0.5em;
}

		</style>
	</head>
	<body>
		<textarea id="source"># Bristol JS

Functional Programming with JavaScript

---

## What I Won't be Talking About

- Functors
- Monads
- Tail Call Optimisation
- Category Theory

---

## What I Will be Talking About

- First Class Functions
- `map`, `reduce`, and `filter`
- Functional Composition
- Partial Application (currying)

---

## First Class Functions

In JavaScript functions can be treated just like any other variable: you can pass them around and create them on the fly.

```javascript
var pointless = function () {
    console.log("Pointless!");
};

var run = function (fn) {
    return fn(); 
};

run(pointless);
```

---

## Executing vs Referencing

This is what happens when non-functional programmers use a functional language:

```javascript
var doSomething = function () {
    alert("You did a thing!");
    document.write("<marquee>Woo!</marquee>");
};

//           old skool!
//               ↓
setTimeout("doSomething()", 1000);
```


---

## Spot the Issue

How can we tidy up this code?

```javascript
var doSomething = function (e) {
    e.preventDefault();

    // do something 
};

document.body.addEventHandler("click", function (e) {
    return doSomething(e);
});
```

---

## Spot the Issue

We can call the function directly, as it takes the same arguments as the wrapper function:

```javascript
var doSomething = function (e) {
    e.preventDefault();

    // do something 
};

document.body.addEventHandler("click", doSomething); 
```

---

## Notes on Style

I'll be using ES6 `let` and arrow syntax from now on:

```javascript
// old skool
var add = function (a, b) {
    return a + b;
};


// nice
let add = (a, b) => a + b;
```

I'll also be using [Ramda.js](http://ramdajs.com) - it's like a functional Underscore

---

# Familiar Functions

---

## Filter

The array `filter` method iterates over each item in an array and returns only those that return `true` when passed to the given function:

```javascript
var numbers = [1, 2, 3, 4, 5, 6];

var oddNumbers = numbers.filter(function (n) {
    return n % 2;
});

console.log(oddNumbers); // [1, 3, 5]
```

Let's make this a bit more modular: 

```javascript
let numbers = [1, 2, 3, 4, 5, 6];

let odd = n => !!(n % 2);

let oddNumbers = numbers.filter(odd);

console.log(oddNumbers); // [1, 3, 5]
```

---

## Map 

The array `map` method iterates over each item in an array and returns an array where each item has been transformed using the given function:

```javascript
let numbers = [1, 2, 3, 4, 5, 6];

let squares = numbers.map(function (n) {
    return n * n;
});

console.log(squares); // [1, 4, 9, 16, 25, 36]
```

Let's make this a bit more modular: 

```javascript
let numbers = [1, 2, 3, 4, 5, 6];

let square = n => n * n;

let squares = numbers.map(square);

console.log(squares); // [1, 4, 9, 16, 25, 36]
```

---

## Reduce 

The array `reduce` method iterates over each item in an array and reduces them down to a single value using the given function:

```javascript
let numbers = [1, 2, 3, 4, 5, 6];

// acc is the cumulative returned value (which we've set to 0 to start)
let sum = numbers.reduce(function (acc, n) {
    return acc + n;
}, 0);

console.log(sum); // 21
```

Let's make this a bit more modular: 

```javascript
let numbers = [1, 2, 3, 4, 5, 6];

let add = (a, b) => a + b;

let sum = numbers.reduce(add, 0);

console.log(sum); // 21
```

---

## Emergent Functions

We've, almost inadvertently, created some useful little functions:

```javascript
let add = (a, b) => a + b;

let square = n => n * n;

let odd = n => !!(n % 2);
```

Unless the laws of mathematics change, these functions will *never* need to be changed at some point in the future.

---

## A Side Note on Side Effects

Ideally, we want to avoid side-effects.

#### Bad

```javascript
let letters = ["a", "b", "c", "d", "e"];

let last = arr => arr.pop();
let e = last(letters);

console.log(e); // "e"
```

#### Good

```javascript
let letters = ["a", "b", "c", "d", "e"];

let last = arr => arr.slice().pop();
let e = last(letters);

console.log(e); // "e"
```

---

## Composition

Composition lets us create a new function out of functions that already exist:

```javascript
import { compose } from "ramda";

let numbers = [1, 2, 3, 4, 5, 6];
let not = n => !n;
let odd = n => !!(n % 2);

// Compose odd and not
let even = compose(not, odd); 

let evenNumbers = numbers.filter(even);
console.log(evenNumbers); // [2, 4, 6]
```

What's happened here?

- First `n` gets passed into `odd`, returning a truthy (`!0`) or falsey (`0`)
- Then, the result of `odd(n)`, gets passed into `not`, which negates the value passed in

Same as doing `let even = n => not(odd(n))`

---

## Composition

[More complicated example]


---

## Partial Application 

Say we want a function that adds 2 to whatever we pass in:

```javascript
let add2 = n => n + 2;

add2(2); // 4
add2(8); // 10
```

What if we want one that adds 3?

```javascript
let add3 = n => n + 3;
```

Can we generalise the creation of adder functions?

```javascript
let makeAdder = function (add) {
    return function (x) {
        return x + add;
    }
}; // or, in ES6 let makeAdder = add => x => add + x;

let add2 = makeAdder(2);
let add5 = makeAdder(5);

add2(3); // 5
add5(5); // 10
```

---

## Partial Application



---

# Example

Procedural to Functional in 11 Steps

---

## Challenge

Log the combined ages of all the coders below:

```json
[{
    "name": "Alice",
    "age": 42
},
{
    "name": "Bob",
    "age": 54
},
{
    "name": "Carol",
    "age": 27
}];
```

---

# Live Coding

Watch me typing!

---

# Criticisms

---

## JavaScript Isn't A Real Functional Language

<iframe width="100%" height="75%" src="https://www.youtube.com/embed/eetWam3nhoM" frameborder="0" allowfullscreen></iframe>

---

## OO Is Best

- By using ES6 modules you can still keep related functions in a single file 

- Programming using `this` in JavaScript can be a nightmare (although much better with ES6)

- Functional programming enforces OO best-practices:
    - Single Responsibility: FP encourages writing small functions that do a single thing 
    - Open/Closed: if a function does one thing well it shouldn't ever need to be changed
    - Prefer Composition Over Inheritance: compose all the things
    - Dependency Injection: the only way to do non-side effect based programming

---

## Functional Programming is less Performant

This one is true, but it's unlikely to have a noticeable effect in anything except the most processor intensive applications (e.g. games).

JS engines are constantly improving the performance of functional code - and it will only get better.

You can build very complex apps using a functional style without any noticeable performance issues.

Because the code is highly modular, you can always tweak individual functions to get easy performance improvements.

---

## Further Reading

#### Basic

- [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) by Michael Fogus
- [JavaScript Allongé](https://leanpub.com/javascriptallongesix) by Reginald Braithwaite
- [Functional Programming for the OO Programmer](https://leanpub.com/fp-oo) by Brian Marick

#### Advanced

- [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://github.com/MostlyAdequate/mostly-adequate-guide) by Brian Lonsdorf

#### Other Functional Languages

- [Learn You A Haskell for Great Good](http://learnyouahaskell.com) by Miran Lipovača
- [The Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/) by Hal Abelson, Jerry Sussman, and Julie Sussman
- [The Little Schemer](https://mitpress.mit.edu/books/little-schemer) by Daniel P. Friedman and Matthias Felleisen

---

## Slides

[http://tiny.cc/bjs-fp](https://github.com/smallhadroncollider/talks--bristol-js--nov-16)
</textarea>
		<script src="http://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
		<script>remark.create({
    ratio: "16:9",

    navigation: {
        scroll: false,
        touch: false,
        click: false,
    },

    highlightStyle: "solarized-dark"
});
</script>
	</body>
</html>
